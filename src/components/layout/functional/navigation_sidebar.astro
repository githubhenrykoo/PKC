---
// Navigation sidebar with direct MCard API integration
interface NavigationItem {
  title: string;
  content: string;
  id?: string;
}

interface Props {
  items?: Array<{
    title: string;
    content: string;
    id?: string;
  }>;
  title?: string;
}

// Fallback items for initial render
const fallbackItems: Array<{
  title: string;
  content: string;
  id?: string;
}> = [
  { title: "Click Refresh to load MCards", content: "empty", id: "empty-message" }
];

const { 
  items = fallbackItems, 
  title = "MCard Navigation"
} = Astro.props as Props;
---

<aside class="rounded-lg bg-[var(--surface)] border border-black/5 dark:border-white/10 p-4">
  <div class="flex justify-between items-center mb-2">
    <h2 class="text-sm font-semibold opacity-70">{title}</h2>
    <span class="text-xs opacity-50" id="page-indicator">1 / 1</span>
  </div>
  
  <!-- Search input with clear button -->
  <div class="mb-3 relative">
    <input 
      id="search-input"
      type="text" 
      placeholder="Search MCards..." 
      class="w-full px-3 py-2 text-sm border rounded-md bg-white dark:bg-black/20 border-black/10 dark:border-white/20 focus:outline-none focus:ring-1 focus:ring-black/20 dark:focus:ring-white/30"
    />
    <button 
      id="search-clear"
      class="absolute right-2 top-1/2 -translate-y-1/2 px-2 py-1 text-xs rounded bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition-colors"
      title="Clear search and refresh data"
    >
      Clear
    </button>
    <div id="search-spinner" class="absolute right-8 top-1/2 -translate-y-1/2 hidden">
      <div class="w-3 h-3 border border-black/20 dark:border-white/30 border-t-transparent rounded-full animate-spin"></div>
    </div>
  </div>
  <ul class="space-y-1 text-sm min-h-[200px]" id="nav-items">
    {items.map((item) => (
      <li>
        <button 
          class="nav-link w-full text-left px-2 py-1 rounded hover:bg-black/5 dark:hover:bg-white/10 transition-colors opacity-80 hover:opacity-100"
          data-content={item.content}
          data-id={item.id || item.title.toLowerCase().replace(/\s+/g, '-')}
        >
          ‚Ä¢ {item.title}
        </button>
      </li>
    ))}
  </ul>
  
  <!-- Pagination controls -->
  <div class="flex justify-between items-center mt-3 pt-3 border-t border-black/5 dark:border-white/10">
    <button 
      id="prev-page" 
      class="px-3 py-1 text-xs rounded bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
      disabled
    >
      ‚Üê Prev
    </button>
    <span class="text-xs opacity-70" id="item-count">
      0 items
    </span>
    <button 
      id="next-page" 
      class="px-3 py-1 text-xs rounded bg-black/5 dark:bg-white/10 hover:bg-black/10 dark:hover:bg-white/20 transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
    >
      Next ‚Üí
    </button>
  </div>
</aside>

<script is:inline>
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('üîß Navigation sidebar initializing...');
    
    // State management
    let allItems = [];
    let currentPage = 1;
    let itemsPerPage = 8;
    let searchActive = false;
    let lastQuery = '';
    let searchPage = 1;
    let searchTotalPages = 1;
    let searchTotalItems = 0;
    
    // Load content-type utilities for icons, labels, title generation, and type resolution
    let inferContentTypeFromFilename, getTypeLabel, getTypeIconSvg, resolveEffectiveContentType, getRendererTypeFromContentType, generateDisplayTitle;
    try {
      const utils = await import('/src/utils/content-type-utils.ts');
      ({ inferContentTypeFromFilename, getTypeLabel, getTypeIconSvg, resolveEffectiveContentType, getRendererTypeFromContentType, generateDisplayTitle } = utils);
      console.log('üß© Content-type utils loaded');
    } catch (e) {
      console.warn('‚ö†Ô∏è Failed to load content-type utils:', e);
      // Fallback functions
      inferContentTypeFromFilename = (filename) => undefined;
      getTypeLabel = (contentType) => 'Document';
      getTypeIconSvg = (contentType) => 'üìÑ';
      resolveEffectiveContentType = (meta) => (meta?.content_type || meta?.contentType || inferContentTypeFromFilename(meta?.filename) || 'text/plain');
      getRendererTypeFromContentType = (ct) => {
        const t = (ct || '').toLowerCase();
        if (t.includes('markdown')) return 'markdown';
        if (t.includes('html')) return 'html';
        if (t.includes('application/json')) return 'json';
        if (t.startsWith('image/')) return 'image';
        if (t.includes('application/pdf')) return 'pdf';
        if (t.startsWith('text/')) return 'text';
        return 'unknown';
      };
      generateDisplayTitle = (src, index) => {
        const name = src?.filename?.replace(/\.[^/.]+$/, '');
        if (name) return name;
        if (src?.metadata?.title) return src.metadata.title;
        const base = 'Document';
        if (typeof index === 'number') return `${base} ${index + 1}`;
        if (src?.hash) return `${base} ${src.hash.substring(0, 8)}`;
        return base;
      };
    }
    
    // Initialize services
    let mcardService = null;
    try {
      const { mcardService: mcs } = await import('/src/services/mcard-service.ts');
      mcardService = mcs;
      console.log('üì¶ MCard service initialized');
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to initialize MCard service:', error);
    }
    
    // DOM elements
    const navItemsContainer = document.getElementById('nav-items');
    const pageIndicator = document.getElementById('page-indicator');
    const itemCount = document.getElementById('item-count');
    const prevButton = document.getElementById('prev-page');
    const nextButton = document.getElementById('next-page');
    const searchInput = document.getElementById('search-input');
    const searchClear = document.getElementById('search-clear');
    const searchSpinner = document.getElementById('search-spinner');
    
    // Debounce utility for smooth interactions
    function debounce(fn, delay) {
      let timeoutId;
      return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(null, args), delay);
      };
    }
    
    // Titles are now generated via shared utils: generateDisplayTitle()
    
    // Format item with type icon and label
    const formatItemTitle = (item, contentType) => {
      const ct = contentType || inferContentTypeFromFilename(item.filename);
      const typeLabel = getTypeLabel(ct);
      const typeIconSvg = getTypeIconSvg(ct);
      const baseTitle = item.title || item.filename?.replace(/\.[^/.]+$/, '') || item.hash?.substring(0, 8) || 'Unknown';
      return `${typeIconSvg} ${baseTitle} <span class="ml-1 text-[10px] px-1 py-0.5 rounded bg-black/5 dark:bg-white/10 align-middle">${typeLabel}</span>`;
    };
    
    // Load MCard data from API
    const loadMCardData = async () => {
      console.log('üîÑ Fetching MCards from API...');
      
      try {
        const apiUrl = window.RUNTIME_ENV?.PUBLIC_MCARD_API_URL || 'http://localhost:49384/v1';
        const response = await fetch(`${apiUrl}/cards?page=1&page_size=100`);
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Loaded', data.items.length, 'MCard items');
          
          // Always fetch per-card metadata so title and type match viewer exactly
          const itemsWithTypes = await Promise.all(
            data.items.map(async (item, index) => {
              let md = null;
              let effectiveType = resolveEffectiveContentType({ content_type: item.content_type, filename: item.filename });
              if (item.hash) {
                try {
                  const metaResp = await fetch(`${apiUrl}/card/${item.hash}/metadata`);
                  if (metaResp.ok) {
                    md = await metaResp.json();
                    effectiveType = resolveEffectiveContentType({ content_type: md.content_type, filename: md.filename });
                  }
                } catch {}
              }
              const titleSource = {
                filename: (md && md.filename) || item.filename,
                metadata: { title: (md && md.title) || (item.metadata && item.metadata.title) },
                content_type: (md && md.content_type) || item.content_type,
                hash: item.hash
              };
              return {
                title: generateDisplayTitle(titleSource),
                content: item.hash,
                id: `mcard-${item.hash.substring(0, 8)}`,
                contentType: effectiveType,
                filename: titleSource.filename,
                gTime: item.g_time,
                hash: item.hash
              };
            })
          );
          allItems = itemsWithTypes;
          
          return true;
        } else {
          console.error('‚ùå API Error:', response.status);
          return false;
        }
      } catch (error) {
        console.error('‚ùå Network Error:', error);
        return false;
      }
    };
    
    // Render current page
    const renderPage = (page) => {
      let pageItems = [];
      let total = 0;
      let totalPages = 1;
      
      if (searchActive) {
        // In search mode, allItems already holds current page of results
        pageItems = allItems;
        total = searchTotalItems;
        totalPages = searchTotalPages;
      } else {
        const startIndex = (page - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;
        pageItems = allItems.slice(startIndex, endIndex);
        total = allItems.length;
        totalPages = Math.max(1, Math.ceil(allItems.length / itemsPerPage));
      }
      
      navItemsContainer.innerHTML = pageItems.map(item => {
        const formattedTitle = formatItemTitle(item, item.contentType);
        return `
          <li>
            <button 
              class="nav-link w-full text-left px-2 py-1 rounded hover:bg-black/5 dark:hover:bg-white/10 transition-colors opacity-80 hover:opacity-100"
              data-hash="${item.hash}"
              data-title="${item.title}"
              data-content-type="${item.contentType || ''}"
              data-g-time="${item.gTime || ''}"
            >
              ${formattedTitle}
            </button>
          </li>
        `;
      }).join('');
      
      // Update UI indicators
      pageIndicator.textContent = `${searchActive ? searchPage : page} / ${totalPages}`;
      itemCount.textContent = `${total} items`;
      
      // Update button states
      prevButton.disabled = searchActive ? searchPage <= 1 : page === 1;
      nextButton.disabled = searchActive ? searchPage >= totalPages : page >= totalPages;
      
      // Setup Redux selection handlers
      setupSelectionHandlers();
    };
    
    // Perform search
    const performSearch = async (query, page = 1) => {
      if (!mcardService) return;
      
      lastQuery = query;
      searchPage = page;
      
      if (!query || query.trim().length === 0) {
        // Exit search mode and return to full list
        searchActive = false;
        currentPage = 1;
        await loadMCardData();
        renderPage(1);
        return;
      }
      
      try {
        searchSpinner.classList.remove('hidden');
        const resp = await mcardService.searchMCards({ query, page, pageSize: itemsPerPage });
        
        searchActive = true;
        searchTotalItems = resp.pagination.totalItems;
        searchTotalPages = resp.pagination.totalPages || 1;
        
        // Map search results; always fetch per-card metadata so titles match viewer
        const apiUrl = window.RUNTIME_ENV?.PUBLIC_MCARD_API_URL || 'http://localhost:49384/v1';
        allItems = await Promise.all(
          resp.results.map(async (res, index) => {
            let md = null;
            let effectiveType = resolveEffectiveContentType({ content_type: res.metadata?.content_type, filename: res.metadata?.filename });
            if (res.hash) {
              try {
                const metaResp = await fetch(`${apiUrl}/card/${res.hash}/metadata`);
                if (metaResp.ok) {
                  md = await metaResp.json();
                  effectiveType = resolveEffectiveContentType({ content_type: md.content_type, filename: md.filename });
                }
              } catch {}
            }
            const titleSource = {
              filename: (md && md.filename) || res.metadata?.filename,
              metadata: { title: (md && md.title) || res.metadata?.title },
              content_type: (md && md.content_type) || res.metadata?.content_type,
              hash: res.hash
            };
            return {
              title: generateDisplayTitle(titleSource),
              content: res.hash,
              id: `mcard-${res.hash.substring(0, 8)}`,
              contentType: effectiveType,
              filename: titleSource.filename,
              gTime: res.metadata?.g_time,
              hash: res.hash
            };
          })
        );
        
        renderPage(currentPage);
      } catch (err) {
        console.warn('Search failed', err);
        navItemsContainer.innerHTML = `<li class='opacity-70 text-xs px-2 py-1'>Search failed. Try again.</li>`;
      } finally {
        searchSpinner.classList.add('hidden');
      }
    };
    
    // Setup Redux selection handlers for navigation links
    function setupSelectionHandlers() {
      const navLinks = document.querySelectorAll('.nav-link');
      navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
          const button = e.currentTarget;
          const hash = button.getAttribute('data-hash');
          const title = button.getAttribute('data-title');
          const contentType = button.getAttribute('data-content-type');
          const gTime = button.getAttribute('data-g-time');
          
          console.log('üéØ MCard selected:', hash);
          
          // Visual feedback
          navLinks.forEach(l => l.classList.remove('bg-black/10', 'dark:bg-white/20'));
          button.classList.add('bg-black/10', 'dark:bg-white/20');
          
          // Redux dispatch
          if (window.reduxStore && typeof window.reduxStore.dispatch === 'function') {
            window.reduxStore.dispatch({
              type: 'mcardSelection/setSelectedMCard',
              payload: { hash, title, gTime: gTime || '', contentType: contentType || '' }
            });
            console.log('‚úÖ Redux dispatched for:', hash);
          } else {
            console.warn('‚ö†Ô∏è Redux store not available');
          }
        });
      });
    }
    
    // Debounced search
    const debouncedSearch = debounce((q) => performSearch(q, 1), 300);
    
    // Event listeners
    searchInput.addEventListener('input', (e) => {
      const q = e.target.value;
      debouncedSearch(q);
    });
    
    searchInput.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        performSearch(e.target.value, 1);
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        searchInput.value = '';
        searchActive = false;
        await loadMCardData();
        renderPage(1);
      }
    });
    
    searchClear.addEventListener('click', async () => {
      searchInput.value = '';
      searchActive = false;
      currentPage = 1;
      await loadMCardData();
      renderPage(1);
    });
    
    // Pagination handlers
    prevButton.addEventListener('click', () => {
      if (searchActive) {
        if (searchPage > 1) {
          searchPage--;
          performSearch(lastQuery, searchPage);
        }
      } else {
        if (currentPage > 1) {
          currentPage--;
          renderPage(currentPage);
        }
      }
    });
    
    nextButton.addEventListener('click', () => {
      if (searchActive) {
        if (searchPage < searchTotalPages) {
          searchPage++;
          performSearch(lastQuery, searchPage);
        }
      } else {
        const totalPages = Math.ceil(allItems.length / itemsPerPage);
        if (currentPage < totalPages) {
          currentPage++;
          renderPage(currentPage);
        }
      }
    });
    
    // Initial load
    await loadMCardData();
    renderPage(1);
  });
</script>
  