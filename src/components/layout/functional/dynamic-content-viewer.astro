---
// Dynamic Content Viewer - Orchestrates MCard content rendering using specialized components
interface Props {
  initialHash?: string;
  initialTitle?: string;
}

const { 
  initialHash = "",
  initialTitle = "Select an item from the navigation to view content"
} = Astro.props as Props;

// Note: renderer registry not needed for client-side dynamic rendering

// Import specialized renderer components
import MarkdownRenderer from '../../../components/mcard/content_type_viewer/MarkdownRenderer.astro';
import HtmlRenderer from '../../../components/mcard/content_type_viewer/HtmlRenderer.astro';
import JsonRenderer from '../../../components/mcard/content_type_viewer/JsonRenderer.astro';
import ImageRenderer from '../../../components/mcard/content_type_viewer/ImageRenderer.astro';
import PdfRenderer from '../../../components/mcard/content_type_viewer/PdfRenderer.astro';
import TextRenderer from '../../../components/mcard/content_type_viewer/TextRenderer.astro';
import UnknownRenderer from '../../../components/mcard/content_type_viewer/UnknownRenderer.astro';
---

<div class="dynamic-content-viewer h-full flex flex-col" data-initial-hash={initialHash} data-initial-title={initialTitle}>
  <!-- Content Header -->
  <div class="content-header p-4 border-b border-black/5 dark:border-white/10">
    <div class="flex justify-between items-start">
      <div class="flex-1">
        <h2 id="content-title" class="text-lg font-semibold opacity-80">{initialTitle}</h2>
        <div id="content-meta" class="text-sm opacity-60 mt-1">
          <span id="content-type">No content selected</span>
          <span id="content-timestamp" class="ml-4"></span>
        </div>
      </div>
      <div id="content-actions" class="gap-2 ml-4 hidden">
        <button 
          id="download-button"
          class="px-3 py-1.5 text-xs rounded bg-green-500 hover:bg-green-600 text-white transition-colors flex items-center gap-1"
          title="Download this MCard"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          Download
        </button>
        <button 
          id="delete-button"
          class="px-3 py-1.5 text-xs rounded bg-red-500 hover:bg-red-600 text-white transition-colors flex items-center gap-1"
          title="Delete this MCard"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            <line x1="10" y1="11" x2="10" y2="17"></line>
            <line x1="14" y1="11" x2="14" y2="17"></line>
          </svg>
          Delete
        </button>
      </div>
    </div>
  </div>

  <!-- Content Display Area with Dynamic Slot -->
  <div class="content-body flex-1 p-4 overflow-auto">
    <div id="content-display" class="h-full">
      <!-- Default placeholder -->
      <div id="content-placeholder" class="h-full flex items-center justify-center text-center opacity-60">
        <div>
          <div class="text-4xl mb-4">üìÑ</div>
          <p>Select an MCard item from the navigation sidebar to view its content</p>
        </div>
      </div>
      
      <!-- Dynamic renderer slot - will be populated by JavaScript -->
      <div id="renderer-slot" class="h-full hidden"></div>
    </div>
  </div>

  <!-- Loading State -->
  <div id="loading-state" class="hidden absolute inset-0 bg-white/80 dark:bg-black/80">
    <div class="text-center">
      <div class="animate-spin w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2"></div>
      <p class="text-sm opacity-70">Loading content...</p>
    </div>
  </div>
</div>

<script type="module">
  // Dynamic Content Viewer - Redux sync functionality
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('üéØ Content viewer initializing...');
    
    const contentTitle = document.getElementById('content-title');
    const contentType = document.getElementById('content-type');
    const contentTimestamp = document.getElementById('content-timestamp');
    const placeholder = document.getElementById('content-placeholder');
    const rendererSlot = document.getElementById('renderer-slot');
    const loadingState = document.getElementById('loading-state');
    const contentActions = document.getElementById('content-actions');
    const downloadButton = document.getElementById('download-button');
    const deleteButton = document.getElementById('delete-button');
    
    // Track current hash for actions
    let currentHash = null;
    let currentFilename = null;

    // Function to get MCard API base URL - reactive to runtime environment changes
    const getMCardApiUrl = () => {
      return window.RUNTIME_ENV?.PUBLIC_MCARD_API_URL || 'http://localhost:49384/v1';
    };
    
    console.log('üîó Content Viewer API URL (initial):', getMCardApiUrl());

    // Function to format timestamp
    const formatTimestamp = (gTime) => {
      try {
        // Parse g_time format: "sha256|2025-08-04T03:36:13.537054|UTC"
        const parts = gTime.split('|');
        if (parts.length >= 2) {
          const dateStr = parts[1];
          const date = new Date(dateStr);
          return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }
      } catch (error) {
        console.error('Error parsing timestamp:', error);
      }
      return gTime;
    };

    // Wait for PKCUtils.content provided by pkcutils-init.ts
    const waitForContentUtils = async (timeout = 5000) => {
      const start = Date.now();
      if (window.PKCUtils?.content) return window.PKCUtils.content;
      return new Promise((resolve) => {
        const iv = setInterval(() => {
          if (window.PKCUtils?.content || Date.now() - start >= timeout) {
            clearInterval(iv);
            resolve(window.PKCUtils?.content);
          }
        }, 50);
      });
    };
    const contentUtils = await waitForContentUtils();
    const {
      getTypeIconSvg = () => '<span>üìÑ</span>',
      getTypeLabel = (t) => t || 'unknown',
      getTypePillHTML = (t) => `<span class="ml-1 text-xs opacity-60">${t || 'unknown'}</span>`,
      inferContentTypeFromFilename = (f) => (f?.endsWith('.md') ? 'text/markdown' : 'text/plain'),
      resolveEffectiveContentType = ({ content_type }) => content_type || 'text/plain',
      getRendererTypeFromContentType = (ct) =>
        ct?.includes('markdown') ? 'markdown' : ct?.includes('html') ? 'html' : ct?.includes('json') ? 'json' : ct?.startsWith('image/') ? 'image' : ct === 'application/pdf' ? 'pdf' : 'text',
      generateDisplayTitle = ({ filename, hash }) => filename || (hash ? hash.substring(0, 8) : 'MCard Content')
    } = contentUtils || {};
    console.log('üß© Content viewer: Using content utils', !!contentUtils);

    // Helper: set title with icon using shared utils
    const setTitleWithIcon = (type, titleText) => {
      const iconSvg = getTypeIconSvg(type);
      const pill = getTypePillHTML(type);
      contentTitle.innerHTML = `${iconSvg} <span class="align-middle">${titleText}</span> ${pill}`;
    };

    // Show/hide loading state
    const showLoading = () => {
      if (loadingState) {
        loadingState.classList.remove('hidden');
        loadingState.classList.add('flex', 'items-center', 'justify-center');
      }
    };
    
    const hideLoading = () => {
      if (loadingState) {
        loadingState.classList.add('hidden');
        loadingState.classList.remove('flex', 'items-center', 'justify-center');
      }
    };

    // Update content metadata display with icons
    const updateContentMeta = (title, type, timestamp) => {
      if (contentTitle && type) {
        // Use setTitleWithIcon for enhanced display
        setTitleWithIcon(type, title || 'MCard Content');
      } else if (contentTitle) {
        contentTitle.textContent = title || 'MCard Content';
      }
      if (contentType) contentType.textContent = type || 'Unknown type';
      if (contentTimestamp && timestamp) {
        contentTimestamp.textContent = timestamp;
      }
    };

    // Note: Single loadMCardContent implementation is defined later with full rendering pipeline

    // Runtime library loader for Marked, DOMPurify, and KaTeX (auto-render)
    // Prefer local vendor files served from /public/vendor, fallback to CDN.
    const ensureRenderLibs = async () => {
      if (!window.__renderLibs) {
        window.__renderLibs = (async () => {
          try {
            // Helper to load CSS with local-first then CDN fallback (best-effort)
            const loadCssLocalFirst = (localHref, cdnHref) => {
              const link = document.createElement('link');
              link.rel = 'stylesheet';
              link.href = localHref;
              link.onerror = () => {
                console.warn(`‚ö†Ô∏è Failed to load CSS from ${localHref}, falling back to CDN`);
                const cdnLink = document.createElement('link');
                cdnLink.rel = 'stylesheet';
                cdnLink.href = cdnHref;
                document.head.appendChild(cdnLink);
              };
              document.head.appendChild(link);
            };

            // Load KaTeX CSS (local first)
            loadCssLocalFirst(
              '/vendor/katex/katex.min.css',
              'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css'
            );

            // Load scripts sequentially with timeout and proper global variable checking
            const loadScript = (src, globalVar, timeout = 10000) => new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = src;
              s.async = true;
              s.onload = () => {
                // Wait a bit for the global variable to be available
                const checkGlobal = () => {
                  if (window[globalVar]) {
                    resolve();
                  } else {
                    setTimeout(checkGlobal, 50);
                  }
                };
                checkGlobal();
              };
              s.onerror = reject;
              document.head.appendChild(s);
              
              // Add timeout
              setTimeout(() => reject(new Error(`Script load timeout: ${src}`)), timeout);
            });

            console.log('üîÑ Loading render libraries (local first, then CDN fallback)...');
            
            // Try multiple CDN sources for reliability
            const tryLoadScript = async (urls, globalVar) => {
              for (const url of urls) {
                try {
                  await loadScript(url, globalVar, 5000);
                  console.log(`‚úÖ ${globalVar} loaded from ${url}`);
                  return;
                } catch (error) {
                  console.warn(`‚ö†Ô∏è Failed to load ${globalVar} from ${url}:`, error.message);
                }
              }
              throw new Error(`Failed to load ${globalVar} from all CDN sources`);
            };

            // Local-first then CDN fallbacks for each library
            await tryLoadScript([
              '/vendor/marked/marked.min.js',
              'https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js',
              'https://unpkg.com/marked@12.0.2/marked.min.js'
            ], 'marked');

            await tryLoadScript([
              '/vendor/dompurify/purify.min.js',
              'https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js',
              'https://unpkg.com/dompurify@3.1.6/dist/purify.min.js'
            ], 'DOMPurify');

            await tryLoadScript([
              '/vendor/katex/katex.min.js',
              'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js',
              'https://unpkg.com/katex@0.16.9/dist/katex.min.js'
            ], 'katex');

            await tryLoadScript([
              '/vendor/katex/auto-render.min.js',
              'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js',
              'https://unpkg.com/katex@0.16.9/dist/contrib/auto-render.min.js'
            ], 'renderMathInElement');

            return {
              marked: window.marked,
              DOMPurify: window.DOMPurify,
              renderMathInElement: window.renderMathInElement
            };
          } catch (error) {
            console.warn('‚ö†Ô∏è Failed to load render libraries:', error);
            // Return fallback functions
            return {
              marked: { parse: (text) => text.replace(/\n/g, '<br>') },
              DOMPurify: { sanitize: (html) => html },
              renderMathInElement: () => {}
            };
          }
        })();
      }
      return window.__renderLibs;
    };

    // Normalize renderer type aliases to our known set
    const normalizeRendererType = (t, contentTypeStr = '') => {
      if (!t) t = '';
      const s = String(t).toLowerCase();
      const ct = String(contentTypeStr || '').toLowerCase();
      const map = {
        'md': 'markdown',
        'markdown-inline': 'markdown',
        'markdown-block': 'markdown',
        'htm': 'html',
        'plain': 'text',
        'plaintext': 'text',
        'txt': 'text',
        'jpeg': 'image',
        'jpg': 'image',
        'png': 'image',
        'gif': 'image',
        'svg': 'image',
        'webp': 'image',
        'pdf': 'pdf',
        'application/pdf': 'pdf'
      };
      let v = map[s] || s;
      // Derive from content-type if needed
      if (!['markdown','html','json','image','pdf','text'].includes(v)) {
        if (ct.includes('markdown')) v = 'markdown';
        else if (ct.includes('html')) v = 'html';
        else if (ct.includes('json')) v = 'json';
        else if (ct.startsWith('image/')) v = 'image';
        else if (ct === 'application/pdf' || ct.includes('pdf')) v = 'pdf';
        else if (ct.startsWith('text/')) v = 'text';
      }
      // Final fallback
      if (!['markdown','html','json','image','pdf','text'].includes(v)) v = 'text';
      return v;
    };

    // Content type detection delegates to shared utility but normalized
    const getRendererType = (contentType) => normalizeRendererType(
      getRendererTypeFromContentType(contentType),
      contentType
    );

    // (Removed local icon generator in favor of shared utils)

    // Dynamic component renderer using registry-based architecture
    const renderContentWithComponent = async (rendererType, content, hash, metadata, contentType) => {
      const placeholder = document.getElementById('content-placeholder');
      const rendererSlot = document.getElementById('renderer-slot');
      
      if (!placeholder || !rendererSlot) return;

      // Hide placeholder and show renderer slot
      placeholder.classList.add('hidden');
      rendererSlot.classList.remove('hidden');
      
      // Load the appropriate component via server-side rendering
      try {
        const response = await fetch('/api/renderer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            rendererType,
            hash,
            metadata,
            contentType
          })
        });
        
        if (response.ok) {
          const componentHTML = await response.text();
          rendererSlot.innerHTML = componentHTML;
        } else {
          throw new Error('Failed to load renderer component');
        }
      } catch (error) {
        console.warn('Failed to load server-rendered component, using fallback:', error);
        // Fallback to inline rendering
        await renderComponentInline(rendererType, content, hash, metadata, contentType);
      }
      
      // Initialize renderer-specific functionality
      await initializeRenderer(rendererType, content, hash);
    };
    
    // Fallback inline renderer
    const renderComponentInline = async (rendererType, content, hash, metadata, contentType) => {
      const rendererSlot = document.getElementById('renderer-slot');
      if (!rendererSlot) return;
      
      let rendererHTML = '';
      const baseUrl = getMCardApiUrl();
      
      switch (rendererType) {
        case 'markdown':
          rendererHTML = `
            <div class="markdown-renderer" data-hash="${hash}">
              <article class="prose dark:prose-invert max-w-none" id="markdown-content-${hash}">
                <!-- Content will be rendered by client-side script -->
              </article>
            </div>
          `;
          break;
          
        case 'html':
          rendererHTML = `
            <div class="html-renderer" data-hash="${hash}">
              <article class="prose dark:prose-invert max-w-none" id="html-content-${hash}">
                <!-- Content will be rendered by client-side script -->
              </article>
            </div>
          `;
          break;
          
        case 'json':
          rendererHTML = `
            <div class="json-renderer" data-hash="${hash}">
              <div class="w-full h-full">
                <pre id="json-content-${hash}" class="whitespace-pre-wrap font-mono text-sm bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border overflow-auto h-full">
                  <!-- Content will be rendered by client-side script -->
                </pre>
              </div>
            </div>
          `;
          break;
          
        case 'image':
          const imageUrl = `${baseUrl}/card/${hash}/content`;
          rendererHTML = `
            <div class="image-renderer" data-hash="${hash}">
              <div class="w-full h-full flex items-center justify-center">
                <img 
                  src="${imageUrl}"
                  alt="MCard Image" 
                  class="max-w-full max-h-full object-contain rounded-lg shadow-lg"
                  loading="lazy"
                />
              </div>
            </div>
          `;
          break;
          
        case 'pdf':
          // Enhanced PDF renderer with full height utilization
          const pdfUrl = `${baseUrl}/card/${hash}/content`;
          rendererHTML = `
            <div class="pdf-renderer h-full w-full flex flex-col" data-hash="${hash}">
              <!-- PDF Preview Container - Takes most of the space -->
              <div class="flex-1 min-h-0 mb-2">
                <iframe 
                  src="${pdfUrl}" 
                  class="w-full h-full border-0 rounded-lg"
                  title="PDF Preview"
                  style="min-height: 600px;"
                  onload="console.log('PDF loaded successfully')"
                  onerror="this.style.display='none'; document.getElementById('pdf-fallback-${hash}').style.display='flex'"
                ></iframe>
                
                <!-- Fallback for browsers that can't display PDF -->
                <div id="pdf-fallback-${hash}" class="w-full h-full hidden flex items-center justify-center text-center">
                  <div>
                    <div class="text-6xl mb-4">üìÑ</div>
                    <h3 class="text-lg font-semibold mb-2">PDF Document</h3>
                    <p class="text-sm opacity-70 mb-4">Your browser cannot display this PDF. Please use the buttons below.</p>
                  </div>
                </div>
              </div>
              
              <!-- PDF Actions - Compact bottom bar -->
              <div class="flex justify-center gap-2 py-2 px-4 bg-gray-50 dark:bg-gray-800 rounded-lg flex-shrink-0">
                <a 
                  href="${pdfUrl}"
                  target="_blank" 
                  rel="noopener noreferrer"
                  class="inline-flex items-center px-3 py-1.5 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 transition-colors"
                >
                  <svg class="w-3 h-3 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                  </svg>
                  Open in New Tab
                </a>
                <a 
                  href="${pdfUrl}"
                  download
                  class="inline-flex items-center px-3 py-1.5 bg-green-500 text-white text-sm rounded hover:bg-green-600 transition-colors"
                >
                  <svg class="w-3 h-3 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                  </svg>
                  Download PDF
                </a>
              </div>
            </div>
          `;
          break;
          
        case 'text':
          rendererHTML = `
            <div class="text-renderer" data-hash="${hash}">
              <article class="prose dark:prose-invert max-w-none" id="text-content-${hash}">
                <!-- Content will be rendered by client-side script -->
              </article>
            </div>
          `;
          break;
          
        default:
          const downloadUrl = `${baseUrl}/card/${hash}/content`;
          rendererHTML = `
            <div class="unknown-renderer" data-hash="${hash}">
              <div class="text-center">
                <div class="text-6xl mb-4">‚ùì</div>
                <h3 class="text-lg font-semibold mb-2">Unknown Content Type</h3>
                <p class="text-sm opacity-70 mb-4">Type: ${contentType}</p>
                <p class="text-sm opacity-70 mb-4">Hash: ${hash}</p>
                <a 
                  href="${downloadUrl}"
                  target="_blank" 
                  rel="noopener noreferrer"
                  class="inline-block px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
                >
                  Download Content
                </a>
              </div>
            </div>
          `;
      }
      
      rendererSlot.innerHTML = rendererHTML;
    };

    // Initialize renderer-specific functionality
    const initializeRenderer = async (rendererType, content, hash) => {
      switch (rendererType) {
        case 'markdown':
          await initializeMarkdownRenderer(content, hash);
          break;
        case 'html':
          await initializeHtmlRenderer(content, hash);
          break;
        case 'json':
          initializeJsonRenderer(content, hash);
          break;
        case 'image':
          await initializeImageRenderer(hash);
          break;
        case 'pdf':
          await initializePdfRenderer(hash);
          break;
        case 'text':
          await initializeTextRenderer(content, hash);
          break;
      }
    };

    // Make ensureRenderLibs globally accessible
    window.ensureRenderLibs = ensureRenderLibs;

    // Renderer initialization functions
    const initializeImageRenderer = async (hash) => {
      // Prefer explicit ID from server-rendered placeholder, fallback to inline img
      const img = document.getElementById(`image-content-${hash}`) 
        || document.querySelector(`.image-renderer[data-hash="${hash}"] img`);
      if (!img) return;
      const baseUrl = getMCardApiUrl();
      img.src = `${baseUrl}/card/${hash}/content`;
    };

    const initializePdfRenderer = async (hash) => {
      // Prefer explicit ID from server-rendered placeholder, fallback to inline iframe
      const iframe = document.getElementById(`pdf-content-${hash}`) 
        || document.querySelector(`.pdf-renderer[data-hash="${hash}"] iframe`);
      if (!iframe) return;
      const baseUrl = getMCardApiUrl();
      iframe.src = `${baseUrl}/card/${hash}/content`;
    };

    const initializeMarkdownRenderer = async (content, hash) => {
      const container = document.getElementById(`markdown-content-${hash}`);
      if (!container) return;

      try {
        console.log('üîÑ Initializing Markdown renderer for hash:', hash.substring(0, 8));
        const libs = await ensureRenderLibs();
        console.log('üìö Render libraries loaded:', { 
          marked: !!libs.marked, 
          DOMPurify: !!libs.DOMPurify, 
          renderMathInElement: !!libs.renderMathInElement 
        });
        
        const raw = libs.marked.parse(content);
        const safe = libs.DOMPurify.sanitize(raw, { USE_PROFILES: { html: true } });
        container.innerHTML = safe;
        console.log('‚úÖ Markdown content rendered');

        try {
          libs.renderMathInElement(container, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
            ]
          });
          console.log('‚úÖ Math rendering completed');
        } catch (e) {
          console.warn('Math rendering failed:', e);
        }
      } catch (error) {
        console.error('Markdown rendering failed:', error);
        container.innerHTML = `<pre class="whitespace-pre-wrap">${content}</pre>`;
      }
    };

    const initializeHtmlRenderer = async (content, hash) => {
      const container = document.getElementById(`html-content-${hash}`);
      if (!container) return;

      try {
        const libs = await ensureRenderLibs();
        const safe = libs.DOMPurify.sanitize(content, { USE_PROFILES: { html: true } });
        container.innerHTML = safe;

        try {
          libs.renderMathInElement(container, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
            ]
          });
        } catch (e) {
          console.warn('Math rendering failed:', e);
        }
      } catch (error) {
        console.error('HTML rendering failed:', error);
        container.innerHTML = `<pre class="whitespace-pre-wrap">${content}</pre>`;
      }
    };

    const initializeJsonRenderer = (content, hash) => {
      const container = document.getElementById(`json-content-${hash}`);
      if (!container) return;

      try {
        const parsed = JSON.parse(content);
        const formatted = JSON.stringify(parsed, null, 2);
        container.textContent = formatted;
      } catch (error) {
        console.warn('JSON parsing failed, displaying as plain text:', error);
        container.textContent = content;
      }
    };

    const initializeTextRenderer = async (content, hash) => {
      const container = document.getElementById(`text-content-${hash}`);
      if (!container) return;

      try {
        const libs = await ensureRenderLibs();
        const raw = libs.marked.parse(content);
        const safe = libs.DOMPurify.sanitize(raw, { USE_PROFILES: { html: true } });
        container.innerHTML = safe;

        try {
          libs.renderMathInElement(container, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
            ]
          });
        } catch (e) {
          console.warn('Math rendering failed:', e);
        }
      } catch (error) {
        console.error('Text rendering failed:', error);
        container.innerHTML = `<pre class="whitespace-pre-wrap">${content}</pre>`;
      }
    };

    // Function to load and display MCard content
    window.loadMCardContent = async (hash, title = 'MCard Content') => {
      try {
        showLoading();
        console.log('üîÑ Loading MCard content for hash:', hash);

        const baseUrl = getMCardApiUrl();
        
        // First, get metadata
        const metaResponse = await fetch(`${baseUrl}/card/${hash}/metadata`);
        if (!metaResponse.ok) {
          throw new Error(`Failed to fetch metadata: ${metaResponse.statusText}`);
        }
        const metadata = await metaResponse.json();
        const effectiveType = resolveEffectiveContentType({ content_type: metadata.content_type, filename: metadata.filename });

        // Store current hash and filename for actions
        currentHash = hash;
        currentFilename = metadata.filename || `mcard-${hash.substring(0, 8)}`;
        
        // Show action buttons
        if (contentActions) {
          contentActions.classList.remove('hidden');
          contentActions.classList.add('flex');
        }

        // Compute unified display title from metadata
        const displayTitle = generateDisplayTitle({ filename: metadata.filename, metadata: { title: metadata.title }, content_type: metadata.content_type, hash }, undefined);
        // Update header info with icon and meta
        setTitleWithIcon(effectiveType, displayTitle);
        contentType.textContent = effectiveType;
        if (metadata.g_time) {
          contentTimestamp.textContent = formatTimestamp(metadata.g_time);
        }

        const isTextContent = effectiveType.startsWith('text/') ||
                              effectiveType.includes('application/json') ||
                              effectiveType.includes('markdown') ||
                              effectiveType.includes('html');

        // Determine renderer type and fetch content accordingly
        const rendererType = getRendererType(effectiveType);
        
        if (isTextContent) {
          // Fetch as text for text-based content
          const contentResponse = await fetch(`${baseUrl}/card/${hash}/content?as_text=true`);
          if (!contentResponse.ok) {
            throw new Error(`Failed to fetch content: ${contentResponse.statusText}`);
          }
          const content = await contentResponse.text();
          await renderContentWithComponent(rendererType, content, hash, metadata, effectiveType);
        } else {
          // For binary content (images, PDFs, etc.), render without fetching content
          await renderContentWithComponent(rendererType, null, hash, metadata, effectiveType);
        }

        console.log('‚úÖ Content loaded successfully');
      } catch (error) {
        console.error('‚ùå Error loading MCard content:', error);
        
        // Show error in renderer slot
        const placeholder = document.getElementById('content-placeholder');
        const rendererSlot = document.getElementById('renderer-slot');
        
        if (placeholder && rendererSlot) {
          placeholder.classList.add('hidden');
          rendererSlot.classList.remove('hidden');
          rendererSlot.innerHTML = `
            <div class="text-center text-red-500">
              <div class="text-4xl mb-4">‚ö†Ô∏è</div>
              <h3 class="text-lg font-semibold mb-2">Error Loading Content</h3>
              <p class="text-sm">${error.message}</p>
            </div>
          `;
        }
      } finally {
        hideLoading();
      }
    };


    // Download button handler
    if (downloadButton) {
      downloadButton.addEventListener('click', async () => {
        if (!currentHash) {
          alert('No content selected');
          return;
        }
        
        try {
          console.log('üì• Downloading MCard:', currentHash);
          downloadButton.disabled = true;
          downloadButton.innerHTML = `
            <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
            </svg>
            Downloading...
          `;
          
          const baseUrl = getMCardApiUrl();
          const downloadUrl = `${baseUrl}/files/${currentHash}?filename=${encodeURIComponent(currentFilename)}`;
          
          // Create a temporary link and trigger download
          const link = document.createElement('a');
          link.href = downloadUrl;
          link.download = currentFilename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          console.log('‚úÖ Download initiated');
          
        } catch (error) {
          console.error('‚ùå Download failed:', error);
          alert(`Download failed: ${error.message}`);
        } finally {
          // Restore button
          downloadButton.disabled = false;
          downloadButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Download
          `;
        }
      });
    }
    
    // Delete button handler
    if (deleteButton) {
      deleteButton.addEventListener('click', async () => {
        if (!currentHash) {
          alert('No content selected');
          return;
        }
        
        const confirmDelete = confirm(`Are you sure you want to delete this MCard?\n\nFilename: ${currentFilename}\nHash: ${currentHash.substring(0, 16)}...\n\nThis action cannot be undone.`);
        if (!confirmDelete) {
          return;
        }
        
        try {
          console.log('üóëÔ∏è Deleting MCard:', currentHash);
          deleteButton.disabled = true;
          deleteButton.innerHTML = `
            <svg class="animate-spin" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
            </svg>
            Deleting...
          `;
          
          const baseUrl = getMCardApiUrl();
          const response = await fetch(`${baseUrl}/card/${currentHash}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            throw new Error(`Delete failed: ${response.status} ${response.statusText}`);
          }
          
          const result = await response.json();
          console.log('‚úÖ MCard deleted successfully:', result);
          
          // Show success message
          alert(`MCard deleted successfully!\n\nFilename: ${currentFilename}`);
          
          // Hide action buttons and reset content
          if (contentActions) {
            contentActions.classList.add('hidden');
            contentActions.classList.remove('flex');
          }
          
          // Reset to placeholder
          if (placeholder && rendererSlot) {
            placeholder.classList.remove('hidden');
            rendererSlot.classList.add('hidden');
            rendererSlot.innerHTML = '';
          }
          
          // Reset title and metadata
          if (contentTitle) {
            contentTitle.textContent = 'Select an item from the navigation to view content';
          }
          if (contentType) {
            contentType.textContent = 'No content selected';
          }
          if (contentTimestamp) {
            contentTimestamp.textContent = '';
          }
          
          // Clear current hash
          currentHash = null;
          currentFilename = null;
          
          // Trigger navigation refresh if available
          if (typeof window.refreshNavigation === 'function') {
            window.refreshNavigation();
          }
          
        } catch (error) {
          console.error('‚ùå Delete failed:', error);
          alert(`Delete failed: ${error.message}`);
        } finally {
          // Restore button
          deleteButton.disabled = false;
          deleteButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="3 6 5 6 21 6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              <line x1="10" y1="11" x2="10" y2="17"></line>
              <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
            Delete
          `;
        }
      });
    }

    // If the container has initial data attributes, load immediately
    const root = document.querySelector('.dynamic-content-viewer');
    if (root) {
      const ih = root.getAttribute('data-initial-hash');
      const it = root.getAttribute('data-initial-title') || 'MCard Content';
      if (ih && ih.trim().length > 0) {
        window.loadMCardContent(ih, it);
      }
    }

    // Redux subscription removed to simplify runtime coordination

    console.log('üéØ Dynamic Content Viewer initialized');
  });
</script>

<style>
  .dynamic-content-viewer {
    position: relative;
  }
  
  .content-body {
    min-height: 400px;
  }
  
  .prose {
    max-width: none;
  }
  
  .animate-spin {
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
</style>
