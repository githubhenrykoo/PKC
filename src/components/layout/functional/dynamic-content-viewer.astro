---
// Dynamic Content Viewer - Displays MCard content based on content type
interface Props {
  initialHash?: string;
  initialTitle?: string;
}

const { 
  initialHash = "",
  initialTitle = "Select an item from the navigation to view content"
} = Astro.props as Props;
---

<div class="dynamic-content-viewer h-full flex flex-col" data-initial-hash={initialHash} data-initial-title={initialTitle}>
  <!-- Content Header -->
  <div class="content-header p-4 border-b border-black/5 dark:border-white/10">
    <h2 id="content-title" class="text-lg font-semibold opacity-80">{initialTitle}</h2>
    <div id="content-meta" class="text-sm opacity-60 mt-1">
      <span id="content-type">No content selected</span>
      <span id="content-timestamp" class="ml-4"></span>
    </div>
  </div>

  <!-- Content Display Area -->
  <div class="content-body flex-1 p-4 overflow-auto">
    <div id="content-display" class="h-full flex items-center justify-center text-center opacity-60">
      <div>
        <div class="text-4xl mb-4">üìÑ</div>
        <p>Select an MCard item from the navigation sidebar to view its content</p>
      </div>
    </div>
  </div>

  <!-- Loading State -->
  <div id="loading-state" class="hidden absolute inset-0 bg-white/80 dark:bg-black/80">
    <div class="text-center">
      <div class="animate-spin w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2"></div>
      <p class="text-sm opacity-70">Loading content...</p>
    </div>
  </div>
</div>

<script is:inline>
  // Dynamic Content Viewer functionality
  document.addEventListener('DOMContentLoaded', () => {
    const contentTitle = document.getElementById('content-title');
    const contentType = document.getElementById('content-type');
    const contentTimestamp = document.getElementById('content-timestamp');
    const contentDisplay = document.getElementById('content-display');
    const loadingState = document.getElementById('loading-state');

    // Function to get MCard API base URL
    const getMCardApiUrl = () => {
      return window.RUNTIME_ENV?.PUBLIC_MCARD_API_URL || 'http://localhost:49384/v1';
    };

    // Function to format timestamp
    const formatTimestamp = (gTime) => {
      try {
        // Parse g_time format: "sha256|2025-08-04T03:36:13.537054|UTC"
        const parts = gTime.split('|');
        if (parts.length >= 2) {
          const dateStr = parts[1];
          const date = new Date(dateStr);
          return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }
      } catch (error) {
        console.error('Error parsing timestamp:', error);
      }
      return gTime;
    };

    // Function to show loading state
    const showLoading = () => {
      loadingState.classList.remove('hidden');
      loadingState.style.display = 'flex';
      loadingState.style.alignItems = 'center';
      loadingState.style.justifyContent = 'center';
    };

    // Function to hide loading state
    const hideLoading = () => {
      loadingState.classList.add('hidden');
      loadingState.style.display = 'none';
    };

    // Runtime library loader for Marked, DOMPurify, and KaTeX (auto-render)
    const ensureRenderLibs = async () => {
      if (!window.__renderLibs) {
        window.__renderLibs = (async () => {
          try {
            // Load KaTeX CSS
            const katexCss = document.createElement('link');
            katexCss.rel = 'stylesheet';
            katexCss.href = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
            document.head.appendChild(katexCss);

            // Load scripts sequentially with timeout
            const loadScript = (src, timeout = 5000) => new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = src;
              s.async = true;
              s.onload = resolve;
              s.onerror = reject;
              document.head.appendChild(s);
              
              // Add timeout
              setTimeout(() => reject(new Error(`Script load timeout: ${src}`)), timeout);
            });

            await loadScript('https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js');
            await loadScript('https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js');
            await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js');
            await loadScript('https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js');

            return {
              marked: window.marked,
              DOMPurify: window.DOMPurify,
              renderMathInElement: window.renderMathInElement
            };
          } catch (error) {
            console.warn('‚ö†Ô∏è Failed to load render libraries:', error);
            // Return fallback functions
            return {
              marked: { parse: (text) => text.replace(/\n/g, '<br>') },
              DOMPurify: { sanitize: (html) => html },
              renderMathInElement: () => {}
            };
          }
        })();
      }
      return window.__renderLibs;
    };

    // Function to display content based on type
    const displayContent = async (content, contentTypeStr, hash) => {
      const type = (contentTypeStr || '').toLowerCase();
      const textContent = typeof content === 'string' ? content : '';
      // Prioritize markdown and HTML
      if (type.includes('markdown')) {
        const { marked, DOMPurify, renderMathInElement } = await ensureRenderLibs();
        const raw = marked.parse(textContent);
        const safe = DOMPurify.sanitize(raw, { USE_PROFILES: { html: true } });
        contentDisplay.innerHTML = `<article class="prose dark:prose-invert max-w-none">${safe}</article>`;
        try { renderMathInElement(contentDisplay, { delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]}); } catch {}
        return;
      }
      if (type.includes('html')) {
        const { DOMPurify, renderMathInElement } = await ensureRenderLibs();
        const safe = DOMPurify.sanitize(textContent, { USE_PROFILES: { html: true } });
        contentDisplay.innerHTML = `<article class="prose dark:prose-invert max-w-none">${safe}</article>`;
        try { renderMathInElement(contentDisplay, { delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]}); } catch {}
        return;
      }
      if (type.includes('image/')) {
        // Display image
        const baseUrl = getMCardApiUrl();
        const imageUrl = `${baseUrl}/card/${hash}/content`;
        contentDisplay.innerHTML = `
          <div class="w-full h-full flex items-center justify-center">
            <img src="${imageUrl}" alt="MCard Image" class="max-w-full max-h-full object-contain rounded-lg shadow-lg" />
          </div>
        `;
      } else if (type.includes('application/json')) {
        // Display text content
        const displayText = JSON.stringify(JSON.parse(textContent || 'null'), null, 2);
        
        contentDisplay.innerHTML = `
          <div class="w-full h-full">
            <pre class="whitespace-pre-wrap font-mono text-sm bg-gray-50 dark:bg-gray-800 p-4 rounded-lg border overflow-auto h-full">${displayText}</pre>
          </div>
        `;
      } else if (type.includes('text/')) {
        // Treat plain text via Marked for typesetting (supports basic MD)
        const { marked, DOMPurify, renderMathInElement } = await ensureRenderLibs();
        const raw = marked.parse(textContent);
        const safe = DOMPurify.sanitize(raw, { USE_PROFILES: { html: true } });
        contentDisplay.innerHTML = `<article class="prose dark:prose-invert max-w-none">${safe}</article>`;
        try { renderMathInElement(contentDisplay, { delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]}); } catch {}
      } else if (type.includes('markdown')) {
        // (handled earlier) fallback
        contentDisplay.textContent = textContent;
      } else if (type.includes('pdf')) {
        // Display PDF info (actual PDF viewing would need additional setup)
        contentDisplay.innerHTML = `
          <div class="text-center">
            <div class="text-6xl mb-4">üìÑ</div>
            <h3 class="text-lg font-semibold mb-2">PDF Document</h3>
            <p class="text-sm opacity-70 mb-4">Hash: ${hash}</p>
            <a href="${getMCardApiUrl()}/card/${hash}/content" target="_blank" 
               class="inline-block px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
              Open PDF in New Tab
            </a>
          </div>
        `;
      } else {
        // Unknown content type
        contentDisplay.innerHTML = `
          <div class="text-center">
            <div class="text-6xl mb-4">‚ùì</div>
            <h3 class="text-lg font-semibold mb-2">Unknown Content Type</h3>
            <p class="text-sm opacity-70 mb-4">Type: ${contentTypeStr}</p>
            <p class="text-sm opacity-70 mb-4">Hash: ${hash}</p>
            <a href="${getMCardApiUrl()}/card/${hash}/content" target="_blank" 
               class="inline-block px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
              Download Content
            </a>
          </div>
        `;
      }
    };

    // Function to load and display MCard content
    window.loadMCardContent = async (hash, title = 'MCard Content') => {
      try {
        showLoading();
        console.log('üîÑ Loading MCard content for hash:', hash);

        const baseUrl = getMCardApiUrl();
        
        // First, get metadata
        const metaResponse = await fetch(`${baseUrl}/card/${hash}/metadata`);
        if (!metaResponse.ok) {
          throw new Error(`Failed to fetch metadata: ${metaResponse.statusText}`);
        }
        
        const metadata = await metaResponse.json();
        console.log('üìã MCard metadata:', metadata);

        // Update header info
        contentTitle.textContent = title;
        // Infer content type if missing
        const inferTypeFromFilename = (name = '') => {
          const n = (name || '').toLowerCase();
          if (n.endsWith('.md') || n.endsWith('.markdown')) return 'text/markdown';
          if (n.endsWith('.html') || n.endsWith('.htm')) return 'text/html';
          if (n.endsWith('.json')) return 'application/json';
          if (n.endsWith('.png')) return 'image/png';
          if (n.endsWith('.jpg') || n.endsWith('.jpeg')) return 'image/jpeg';
          if (n.endsWith('.gif')) return 'image/gif';
          if (n.endsWith('.pdf')) return 'application/pdf';
          if (n.endsWith('.txt')) return 'text/plain';
          return 'text/plain';
        };
        const effectiveType = (metadata.content_type && String(metadata.content_type)) || inferTypeFromFilename(metadata.filename) || 'text/plain';
        contentType.textContent = effectiveType;
        contentTimestamp.textContent = formatTimestamp(metadata.g_time);

        // Get content based on type
        const isTextContent = effectiveType.includes('text/') || 
                             effectiveType.includes('application/json') ||
                             effectiveType.includes('markdown') ||
                             effectiveType.includes('html');

        if (isTextContent) {
          // Fetch as text
          const contentResponse = await fetch(`${baseUrl}/card/${hash}/content?as_text=true`);
          if (!contentResponse.ok) {
            throw new Error(`Failed to fetch content: ${contentResponse.statusText}`);
          }
          const content = await contentResponse.text();
          displayContent(content, effectiveType, hash);
        } else {
          // For binary content (images, PDFs, etc.), just display based on type
          displayContent(null, effectiveType, hash);
        }

        console.log('‚úÖ Content loaded successfully');
      } catch (error) {
        console.error('‚ùå Error loading MCard content:', error);
        contentDisplay.innerHTML = `
          <div class="text-center text-red-500">
            <div class="text-4xl mb-4">‚ö†Ô∏è</div>
            <h3 class="text-lg font-semibold mb-2">Error Loading Content</h3>
            <p class="text-sm">${error.message}</p>
          </div>
        `;
      } finally {
        hideLoading();
      }
    };

    // Navigation clicks are now handled by the sidebar's custom event system

    // Listen for explicit selection events from the navigation sidebar
    document.addEventListener('mcard-selected', (e) => {
      try {
        const detail = (e && 'detail' in e) ? e.detail : {};
        const hash = detail.hash;
        const title = detail.title || 'MCard Content';
        if (hash && typeof hash === 'string') {
          window.loadMCardContent(hash, title);
        }
      } catch {}
    });

    // If the container has initial data attributes, load immediately
    const root = document.querySelector('.dynamic-content-viewer');
    if (root) {
      const ih = root.getAttribute('data-initial-hash');
      const it = root.getAttribute('data-initial-title') || 'MCard Content';
      if (ih && ih.trim().length > 0) {
        window.loadMCardContent(ih, it);
      }
    }

    console.log('üéØ Dynamic Content Viewer initialized');
  });
</script>

<style>
  .dynamic-content-viewer {
    position: relative;
  }
  
  .content-body {
    min-height: 400px;
  }
  
  .prose {
    max-width: none;
  }
  
  .animate-spin {
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
</style>
